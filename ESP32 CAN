/* =======================================================================
 *  Telemetry Gateway — ESP32 + MCP2515  ->  Wi-Fi + MQTT
 *  - CAN @500 kbps (IDs: 0x100..0x150) desde STM32F407
 *  - Publicación MQTT con tópicos: baja/<vehiculoId>/...
 *  - LWT online/offline en /health
 *  - Reintentos con backoff simple
 *  -----------------------------------------------------------------------
 *  Pines (VSPI por defecto ESP32):
 *    SCK=18, MISO=19, MOSI=23, CS=5, INT=27    (ajustar si usas otros)
 *  MCP2515 requiere transceptor CAN (TJA1050/MCP2551) + 120Ω en extremos.
 * =======================================================================*/

#include <WiFi.h>
#include <PubSubClient.h>
#include <SPI.h>
#include <mcp_can.h>

/* ---------- Configuración Wi-Fi ---------- */
const char* WIFI_SSID = "TU_SSID";
const char* WIFI_PASS = "TU_PASSWORD";

/* ---------- Configuración MQTT ---------- */
const char* MQTT_HOST = "192.168.1.100";   // Broker Mosquitto
const uint16_t MQTT_PORT = 1883;           // 8883 si usas TLS
const char* VEHICULO_ID = "01";            // <vehiculoId>
const char* CLIENT_ID   = "baja_gw_01";    // ID del cliente MQTT

// Nota: PubSubClient solo soporta QoS 0. Para QoS>0 necesitarías otra librería.
WiFiClient net;
PubSubClient mqtt(net);

/* ---------- Tópicos (plantillas) ---------- */
String topicWheelFL, topicWheelFR, topicWheelRL, topicWheelRR;
String topicIMU, topicGPS, topicTempBox, topicTempMotor, topicBrake, topicHealth;

/* ---------- Configuración MCP2515 ---------- */
#define PIN_CS   5
#define PIN_INT 27
MCP_CAN CAN(PIN_CS);

/* ---------- Helpers ---------- */
static inline int16_t be16(const uint8_t* p){ return (int16_t)((p[0]<<8)|p[1]); }
static inline uint16_t ube16(const uint8_t* p){ return (uint16_t)((p[0]<<8)|p[1]); }

/* ---------- Backoff reconexión ---------- */
unsigned long nextAttempt = 0;
unsigned long backoffMs = 1000;  // 1s, duplica hasta 30s

/* =========================  Conexión Wi-Fi  ========================= */
void wifiConnect(){
  if (WiFi.status() == WL_CONNECTED) return;
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print(F("[WiFi] Conectando"));
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis()-t0 < 15000){
    Serial.print('.');
    delay(500);
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED){
    Serial.print(F("[WiFi] OK, IP: ")); Serial.println(WiFi.localIP());
  } else {
    Serial.println(F("[WiFi] ERROR"));
  }
}

/* =========================  Conexión MQTT  ========================= */
void mqttSetupTopics(){
  const String base = String("baja/") + VEHICULO_ID + "/";
  topicWheelFL  = base + "kinematics/wheels/FL";
  topicWheelFR  = base + "kinematics/wheels/FR";
  topicWheelRL  = base + "kinematics/wheels/RL";
  topicWheelRR  = base + "kinematics/wheels/RR";
  topicIMU      = base + "imu";
  topicGPS      = base + "gps";
  topicTempBox  = base + "temp/mcu_box";
  topicTempMotor= base + "temp/motor";
  topicBrake    = base + "brake/position";
  topicHealth   = base + "health";
}

void mqttConnect(){
  if (mqtt.connected()) return;
  mqtt.setServer(MQTT_HOST, MQTT_PORT);

  // Last Will & Testament (retain=true)
  String willPayload = "{\"status\":\"offline\"}";
  if (mqtt.connect(CLIENT_ID, NULL, NULL, topicHealth.c_str(), 0, true, willPayload.c_str())){
    Serial.println(F("[MQTT] Conectado"));
    // Publica ONLINE (retain=true)
    String online = "{\"status\":\"online\"}";
    mqtt.publish(topicHealth.c_str(), online.c_str(), true);
    backoffMs = 1000; // reset backoff
  } else {
    Serial.print(F("[MQTT] Falla rc=")); Serial.println(mqtt.state());
  }
}

/* =========================  Publicadores JSON  ========================= */
void pubWheel(const String& topic, float mps){
  // m/s, 3 decimales
  char msg[96];
  snprintf(msg, sizeof(msg),
           "{\"ts\":%lu,\"value\":%.3f,\"unit\":\"mps\"}",
           (unsigned long)millis(), mps);
  mqtt.publish(topic.c_str(), msg, false);
}

void pubIMU(float ax,float ay,float az,float gx,float gy,float gz){
  char msg[180];
  snprintf(msg, sizeof(msg),
    "{\"ts\":%lu,\"imu\":{\"ax\":%.2f,\"ay\":%.2f,\"az\":%.2f,\"gx\":%.3f,\"gy\":%.3f,\"gz\":%.3f}}",
    (unsigned long)millis(), ax, ay, az, gx, gy, gz);
  mqtt.publish(topicIMU.c_str(), msg, false);
}

void pubGPS(float speed_mps){
  char msg[96];
  snprintf(msg, sizeof(msg),
    "{\"ts\":%lu,\"gps\":{\"speed\":%.2f}}",
    (unsigned long)millis(), speed_mps);
  mqtt.publish(topicGPS.c_str(), msg, false);
}

void pubTemps(float boxC, float motC){
  char msg[96];
  snprintf(msg, sizeof(msg),
    "{\"ts\":%lu,\"mcu_box\":%.1f,\"motor\":%.1f}",
    (unsigned long)millis(), boxC, motC);
  // Publica en ambos tópicos (o cambia a un solo topic general si prefieres)
  mqtt.publish(topicTempBox.c_str(), msg, false);
  mqtt.publish(topicTempMotor.c_str(), msg, false);
}

void pubBrake(float pos01){
  char msg[80];
  if (pos01 < 0) pos01 = 0;
  if (pos01 > 1) pos01 = 1;
  snprintf(msg, sizeof(msg),
    "{\"ts\":%lu,\"position\":%.3f}",
    (unsigned long)millis(), pos01);
  mqtt.publish(topicBrake.c_str(), msg, false);
}

void pubHealth(float vbat, int rssi, int cpuLoad){
  char msg[128];
  snprintf(msg, sizeof(msg),
    "{\"ts\":%lu,\"vbat\":%.2f,\"rssi\":%d,\"cpu_load\":%d,\"status\":\"online\"}",
    (unsigned long)millis(), vbat, rssi, cpuLoad);
  mqtt.publish(topicHealth.c_str(), msg, true); // retain último estado
}

/* =========================  Decodificación de CAN  =========================
 *  Tramas desde STM32 (Cap. 5):
 *   0x100..0x103  wheel_mps:   int16 = m/s * 1000   (2 bytes)
 *   0x110        IMU:          ax,ay,az (x100), gz (x1000) -> 8 bytes
 *   0x120        GPS speed:    int16 = m/s * 100    (2 bytes)
 *   0x130        TEMP:         box (x10), motor (x10) -> 4 bytes
 *   0x140        BRAKE:        uint16 = pos*1000     (2 bytes)
 *   0x150        HEALTH:       vbat(x100), rssi(int8), cpu(uint8), status(0x01)
 * ======================================================================== */
void handleCANFrame(unsigned long id, uint8_t* buf, uint8_t len){
  switch(id){
    case 0x100: { float v = be16(buf)/1000.0f; pubWheel(topicWheelFL, v); } break;
    case 0x101: { float v = be16(buf)/1000.0f; pubWheel(topicWheelFR, v); } break;
    case 0x102: { float v = be16(buf)/1000.0f; pubWheel(topicWheelRL, v); } break;
    case 0x103: { float v = be16(buf)/1000.0f; pubWheel(topicWheelRR, v); } break;

    case 0x110: {
      if (len>=8){
        float ax = be16(buf+0)/100.0f;
        float ay = be16(buf+2)/100.0f;
        float az = be16(buf+4)/100.0f;
        float gz = be16(buf+6)/1000.0f;
        pubIMU(ax,ay,az, 0,0,gz); // gx/gy 0 por ahorro de payload; ajusta si los envías
      }
    } break;

    case 0x120: {
      float sp = be16(buf)/100.0f;
      pubGPS(sp);
    } break;

    case 0x130: {
      if (len>=4){
        float box = be16(buf+0)/10.0f;
        float mot = be16(buf+2)/10.0f;
        pubTemps(box, mot);
      }
    } break;

    case 0x140: {
      float pos = ube16(buf)/1000.0f;
      pubBrake(pos);
    } break;

    case 0x150: {
      float vbat = be16(buf)/100.0f;
      int8_t rssi = (int8_t)buf[2];
      uint8_t cpu = buf[3];
      pubHealth(vbat, rssi, cpu);
    } break;

    default: /* ignorar otros IDs */ break;
  }
}

/* =========================  Setup  ========================= */
void setup() {
  Serial.begin(115200);
  delay(100);

  mqttSetupTopics();
  wifiConnect();
  mqttConnect();

  // SPI + MCP2515
  SPI.begin(18, 19, 23, PIN_CS);
  pinMode(PIN_INT, INPUT);
  // Inicia MCP2515 a 16 MHz, 500 kbps
  if (CAN.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK) {
    Serial.println(F("[CAN] MCP2515 OK"));
  } else {
    Serial.println(F("[CAN] ERROR init"));
  }
  CAN.setMode(MCP_NORMAL);
}

/* =========================  Loop  ========================= */
void loop() {
  // Mantener conexiones
  if (WiFi.status() != WL_CONNECTED || !mqtt.connected()){
    unsigned long now = millis();
    if (now >= nextAttempt){
      wifiConnect();
      mqttConnect();
      nextAttempt = now + backoffMs;
      backoffMs = min<unsigned long>(backoffMs*2, 30000);
    }
  }
  mqtt.loop();

  // Leer frames CAN (polling)
  if (!digitalRead(PIN_INT)){  // INT activo bajo
    long unsigned int rxId;
    unsigned char len = 0;
    unsigned char buf[8];
    if (CAN.readMsgBuf(&rxId, &len, buf) == CAN_OK){
      handleCANFrame(rxId, buf, len);
    }
  }
}
