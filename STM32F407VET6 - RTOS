/* ===========================
 *  Proyecto: Telemetría Baja SAE - STM32F407VET6
 *  HAL + FreeRTOS
 *  Adquisición (VR/IMU/GPS/Temp/Freno) -> Procesamiento -> CAN Tx
 *  =========================== */

// Incluye cabeceras principales del proyecto y HAL
#include "main.h"         // Debe contener definiciones de pines, prototipos y variables globales
#include "cmsis_os.h"     // FreeRTOS API
#include <string.h>
#include <math.h>

/* Periféricos generados por CubeMX (deben estar definidos en main.h) */
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;
CAN_HandleTypeDef hcan1;
TIM_HandleTypeDef htim2;

/* ===========================
   Definiciones del sistema
   =========================== */
#define FW_VERSION             "stm32f407_rtos_1.3.2"

/* IDs de mensajes CAN para cada sensor/dispositivo */
#define CAN_ID_VR_FL           0x100
#define CAN_ID_VR_FR           0x101
#define CAN_ID_VR_RL           0x102
#define CAN_ID_VR_RR           0x103
#define CAN_ID_IMU             0x110
#define CAN_ID_GPS             0x120
#define CAN_ID_TEMP            0x130
#define CAN_ID_BRAKE           0x140
#define CAN_ID_HEALTH          0x150

/* Frecuencias de muestreo para cada tarea */
#define RATE_PROC_HZ           100U     // procesamiento/empacado
#define RATE_IMU_HZ            200U
#define RATE_GPS_HZ            10U
#define RATE_TEMP_HZ           20U
#define RATE_HEALTH_HZ         2U

/* Número de canales ADC usados (temperatura y freno) */
#define ADC_NUM_CH             3

/* Dirección y registros del MPU6050 (IMU) */
#define MPU6050_ADDR           (0x68<<1)
#define MPU6050_REG_PWR_MGMT1  0x6B
#define MPU6050_REG_ACCEL_XOUT 0x3B

/* Buffers globales para ISR y DMA (volatile) */
volatile uint32_t vr_ic_ticks[4] = {0};     // Última captura por canal (ruedas)
volatile uint32_t vr_period_ticks[4] = {0}; // Periodo medido (ticks timer)
volatile uint8_t  vr_new[4] = {0};          // Flag de nueva medición

volatile uint16_t adc_buf[ADC_NUM_CH];      // Buffer ADC DMA circular
volatile uint8_t  adc_new = 0;              // Flag de nueva conversión ADC

#define GPS_RX_BUF_SZ 256
volatile uint8_t gps_rx_byte;               // Byte recibido por UART
volatile char gps_rx_buf[GPS_RX_BUF_SZ];    // Buffer de recepción GPS
volatile uint16_t gps_rx_w = 0;             // Índice de escritura en buffer

/* Estructuras de datos para telemetría cruda y procesada */
typedef struct {
  float wheel_mps[4];  // Velocidad de cada rueda (m/s)
  float imu_ax, imu_ay, imu_az; // Aceleraciones IMU
  float imu_gx, imu_gy, imu_gz; // Giroscopio IMU
  float gps_speed_mps;          // Velocidad GPS (m/s)
  double gps_lat, gps_lon;      // Latitud y longitud GPS
  float temp_box_c;             // Temperatura caja
  float temp_motor_c;           // Temperatura motor
  float brake_pos;              // Posición freno (0..1)
  uint32_t ts_ms;               // Timestamp en ms
} TelemetryRaw_t;

typedef struct {
  float wheel_mps[4];
  float v_total_mps;            // Velocidad total fusionada
  float ax, ay, az;             // Aceleraciones procesadas
  float gz;                     // Giroscopio Z procesado
  float temp_box_c, temp_motor_c;
  float brake_pos;
  float gps_speed_mps;
  uint32_t ts_ms;
} TelemetryProc_t;

/* Colas RTOS para pasar datos entre tareas */
QueueHandle_t q_raw;      // Cola de datos crudos (TelemetryRaw_t)
QueueHandle_t q_proc;     // Cola de datos procesados (TelemetryProc_t)

/* Prototipos de tareas RTOS */
void task_acq(void *arg);      // Adquisición de sensores
void task_proc(void *arg);     // Procesamiento/fusión de datos
void task_can(void *arg);      // Envío por CAN
void task_health(void *arg);   // Estado del sistema

/* Prototipos de inicialización CubeMX */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM2_Init(void);
static void MX_CAN1_Init(void);

/* Utilidades */
static inline uint32_t millis(void) { return HAL_GetTick(); } // Retorna ms desde arranque
float lpf(float x, float y_prev, float alpha) { return alpha*x + (1.0f-alpha)*y_prev; } // Filtro paso bajo

/* ===========================
   GPS: parseo mínimo GPRMC (speed knots -> m/s)
   =========================== */
// Extrae velocidad, latitud y longitud de una trama NMEA $GPRMC
static int parse_gprmc_speed(const char *nmea, float *speed_mps, double *lat, double *lon) {
  // Busca "$GPRMC", separa por comas. Formato básico: $GPRMC,time,status,lat,N,lon,E,speedKnots,course,date,...
  const char *p = strstr(nmea, "$GPRMC");
  if (!p) return 0;
  // Copia línea hasta CR/LF
  char line[128]; size_t i=0;
  while (*p && *p!='\n' && *p!='\r' && i<sizeof(line)-1) line[i++]=*p++;
  line[i]='\0';
  // Tokenizar
  char *tok; char *ctx;
  int field=0; char buf[128]; strncpy(buf,line,sizeof(buf));
  double lat_raw=0, lon_raw=0; char lat_ns='N', lon_ew='E';
  float spd_kn=0;
  for (tok=strtok_r(buf,",",&ctx); tok; tok=strtok_r(NULL,",",&ctx), field++) {
    if(field==2){ if(tok[0]!='A') return 0; } // status 'A'ctive
    else if(field==3){ lat_raw=atof(tok); }
    else if(field==4){ lat_ns=tok[0]; }
    else if(field==5){ lon_raw=atof(tok); }
    else if(field==6){ lon_ew=tok[0]; }
    else if(field==7){ spd_kn=atof(tok); }
  }
  // Convierte lat/long ddmm.mmmm -> grados decimales
  int lat_deg=(int)(lat_raw/100.0); double lat_min=lat_raw - lat_deg*100.0;
  int lon_deg=(int)(lon_raw/100.0); double lon_min=lon_raw - lon_deg*100.0;
  double lat_dec = lat_deg + lat_min/60.0;
  double lon_dec = lon_deg + lon_min/60.0;
  if(lat_ns=='S') lat_dec=-lat_dec;
  if(lon_ew=='W') lon_dec=-lon_dec;

  *speed_mps = spd_kn * 0.514444f; // knots a m/s
  if(lat) *lat=lat_dec;
  if(lon) *lon=lon_dec;
  return 1;
}

/* ===========================
   MPU6050: init + lectura burst
   =========================== */
// Inicializa el MPU6050 (quita sleep)
static HAL_StatusTypeDef mpu6050_init(void){
  uint8_t d[2] = {MPU6050_REG_PWR_MGMT1, 0x00}; // wake up
  return HAL_I2C_Master_Transmit(&hi2c1, MPU6050_ADDR, d, 2, 100);
}
// Lee acelerómetro y giroscopio (6 ejes)
static HAL_StatusTypeDef mpu6050_read6(float *ax,float *ay,float *az,float *gx,float *gy,float *gz){
  uint8_t reg = MPU6050_REG_ACCEL_XOUT;
  uint8_t rx[14];
  if(HAL_I2C_Master_Transmit(&hi2c1, MPU6050_ADDR, &reg, 1, 100)!=HAL_OK) return HAL_ERROR;
  if(HAL_I2C_Master_Receive(&hi2c1, MPU6050_ADDR, rx, 14, 100)!=HAL_OK) return HAL_ERROR;
  int16_t axr=(rx[0]<<8)|rx[1], ayr=(rx[2]<<8)|rx[3], azr=(rx[4]<<8)|rx[5];
  int16_t gxr=(rx[8]<<8)|rx[9], gyr=(rx[10]<<8)|rx[11], gzr=(rx[12]<<8)|rx[13];
  /* Escalas típicas: AFS=±2g -> 16384 LSB/g; GFS=±250 dps -> 131 LSB/(°/s) */
  if(ax) *ax = axr/16384.0f * 9.80665f;
  if(ay) *ay = ayr/16384.0f * 9.80665f;
  if(az) *az = azr/16384.0f * 9.80665f;
  if(gx) *gx = gxr/131.0f*(float)M_PI/180.0f;
  if(gy) *gy = gyr/131.0f*(float)M_PI/180.0f;
  if(gz) *gz = gzr/131.0f*(float)M_PI/180.0f;
  return HAL_OK;
}

/* ===========================
   CAN: helper de envío
   =========================== */
// Inicializa y configura el filtro CAN
static void can_start(void){
  CAN_FilterTypeDef f = {0};
  f.FilterBank = 0; f.FilterMode = CAN_FILTERMODE_IDMASK; f.FilterScale = CAN_FILTERSCALE_32BIT;
  f.FilterIdHigh = 0; f.FilterIdLow = 0; f.FilterMaskIdHigh = 0; f.FilterMaskIdLow = 0;
  f.FilterFIFOAssignment = CAN_FILTER_FIFO0; f.FilterActivation = ENABLE;
  HAL_CAN_ConfigFilter(&hcan1, &f);
  HAL_CAN_Start(&hcan1);
}

// Envia un mensaje CAN de hasta 8 bytes
static void can_send_u8(uint16_t id, const uint8_t *p, uint8_t len){
  CAN_TxHeaderTypeDef tx={0}; tx.StdId=id; tx.IDE=CAN_ID_STD; tx.RTR=CAN_RTR_DATA; tx.DLC=len;
  uint32_t mb;
  HAL_CAN_AddTxMessage(&hcan1, &tx, (uint8_t*)p, &mb);
}

// Empaquetadores para cada tipo de dato (ruedas, freno, temp, IMU, GPS, health)
static void send_wheel_speed(uint16_t id, float mps){
  int16_t v = (int16_t)(mps*1000); // m/s * 1e3
  uint8_t d[2] = { (uint8_t)(v>>8), (uint8_t)v };
  can_send_u8(id, d, 2);
}
static void send_brake(float pos){
  uint16_t v=(uint16_t)(fmaxf(0.0f,fminf(1.0f,pos))*1000);
  uint8_t d[2] = {(uint8_t)(v>>8),(uint8_t)v}; can_send_u8(CAN_ID_BRAKE,d,2);
}
static void send_temp(float c_box, float c_motor){
  int16_t a=(int16_t)(c_box*10), b=(int16_t)(c_motor*10);
  uint8_t d[4]={a>>8,a&0xFF,b>>8,b&0xFF}; can_send_u8(CAN_ID_TEMP,d,4);
}
static void send_imu(float ax,float ay,float az,float gz){
  int16_t iax=ax*100, iay=ay*100, iaz=az*100, igz=gz*1000;
  uint8_t d[8]={iax>>8,iax, iay>>8,iay, iaz>>8,iaz, igz>>8,igz};
  can_send_u8(CAN_ID_IMU,d,8);
}
static void send_gps(float speed_mps){
  int16_t v=speed_mps*100; uint8_t d[2]={v>>8,v}; can_send_u8(CAN_ID_GPS,d,2);
}
static void send_health(float vbat, int8_t rssi, uint8_t cpu){
  int16_t vb=vbat*100; uint8_t d[5]={vb>>8,vb, (uint8_t)rssi, cpu, 0x01 /*online*/};
  can_send_u8(CAN_ID_HEALTH,d,5);
}

/* ===========================
   main
   =========================== */
int main(void)
{
  HAL_Init();                 // Inicializa HAL y Systick
  SystemClock_Config();       // Configura reloj del sistema
  MX_GPIO_Init();             // Inicializa GPIOs
  MX_DMA_Init();              // Inicializa DMA
  MX_I2C1_Init();             // Inicializa I2C1
  MX_USART2_UART_Init();      // Inicializa UART2 (GPS)
  MX_ADC1_Init();             // Inicializa ADC1
  MX_TIM2_Init();             // Inicializa Timer2 (Input Capture)
  MX_CAN1_Init();             // Inicializa CAN1

  can_start();                // Inicia CAN y filtro
  mpu6050_init();             // Inicializa IMU

  /* ADC DMA continuo */
  HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buf, ADC_NUM_CH);

  /* GPS UART RX IT */
  HAL_UART_Receive_IT(&huart2, (uint8_t*)&gps_rx_byte, 1);

  /* TIM2 Input Capture CH1..CH4 */
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_2);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_3);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_4);

  /* Colas */
  q_raw  = xQueueCreate(8, sizeof(TelemetryRaw_t));
  q_proc = xQueueCreate(8, sizeof(TelemetryProc_t));

  /* Tareas */
  xTaskCreate(task_acq,   "acq",   512, NULL, tskIDLE_PRIORITY+4, NULL);
  xTaskCreate(task_proc,  "proc",  512, NULL, tskIDLE_PRIORITY+3, NULL);
  xTaskCreate(task_can,   "canTx", 512, NULL, tskIDLE_PRIORITY+3, NULL);
  xTaskCreate(task_health,"health",384, NULL, tskIDLE_PRIORITY+1, NULL);

  vTaskStartScheduler();      // Inicia el planificador FreeRTOS
  while (1) { }               // Nunca debe llegar aquí
}

/* ===========================
   Tarea de Adquisición
   =========================== */
// Lee sensores y llena TelemetryRaw_t
void task_acq(void *arg)
{
  const TickType_t dt_imu   = pdMS_TO_TICKS(1000/RATE_IMU_HZ);
  const TickType_t dt_gps   = pdMS_TO_TICKS(1000/RATE_GPS_HZ);
  const TickType_t dt_temp  = pdMS_TO_TICKS(1000/RATE_TEMP_HZ);
  TickType_t t_imu = xTaskGetTickCount();
  TickType_t t_gps = t_imu;
  TickType_t t_tmp = t_imu;

  TelemetryRaw_t r={0};

  for(;;){
    uint32_t now = millis();
    r.ts_ms = now;

    // 1) VR: convierte periodos -> m/s (requiere radio/relación; aquí k simple)
    const float K_TICK_TO_MPS = 0.001f; // <-- AJUSTAR con geometría real
    for(int i=0;i<4;i++){
      if(vr_new[i]){ vr_new[i]=0; r.wheel_mps[i] = (vr_period_ticks[i]>0)? (K_TICK_TO_MPS/vr_period_ticks[i]) : 0.0f; }
    }

    // 2) IMU
    if(xTaskGetTickCount() - t_imu >= dt_imu){
      t_imu += dt_imu;
      mpu6050_read6(&r.imu_ax,&r.imu_ay,&r.imu_az,&r.imu_gx,&r.imu_gy,&r.imu_gz);
    }

    // 3) GPS: se parsea del buffer RX; aquí cada periodo se intenta extraer última GPRMC
    if(xTaskGetTickCount() - t_gps >= dt_gps){
      t_gps += dt_gps;
      char tmp[GPS_RX_BUF_SZ]; uint16_t n=0;
      __disable_irq();
      n = (gps_rx_w<GPS_RX_BUF_SZ)? gps_rx_w : GPS_RX_BUF_SZ-1;
      memcpy(tmp, (const void*)gps_rx_buf, n); tmp[n]='\0'; gps_rx_w=0;
      __enable_irq();
      parse_gprmc_speed(tmp, &r.gps_speed_mps, &r.gps_lat, &r.gps_lon);
    }

    // 4) ADC (temperatura y freno)
    if(xTaskGetTickCount() - t_tmp >= dt_temp){
      t_tmp += dt_temp;
      // Copia atómica
      __disable_irq();
      uint16_t a0=adc_buf[0], a1=adc_buf[1], a2=adc_buf[2];
      __enable_irq();
      // Convertir a físicas (ejemplo: Vref=3.3, 12 bits)
      float v0 = a0*(3.3f/4095.0f), v1=a1*(3.3f/4095.0f), v2=a2*(3.3f/4095.0f);
      r.temp_box_c   = v0*100.0f;   // LM35 (10mV/°C) después del acondicionamiento
      r.temp_motor_c = v1*100.0f;
      r.brake_pos    = fminf(1.0f, fmaxf(0.0f, v2/3.3f)); // normalizado 0..1
    }

    // Empujar muestra "raw" a la cola (no bloquear)
    xQueueOverwrite(q_raw, &r);
    vTaskDelay(pdMS_TO_TICKS(5)); // pequeño sleep para ceder CPU
  }
}

/* ===========================
   Tarea de Procesamiento (filtros sencillos + fusión básica)
   =========================== */
// Aplica filtros y fusiona datos, llena TelemetryProc_t
void task_proc(void *arg)
{
  TelemetryRaw_t  r = {0};
  TelemetryProc_t p = {0};
  const float a_w = 0.2f;   // LPF ruedas
  const float a_t = 0.1f;   // LPF temp
  for(;;){
    if(xQueueReceive(q_raw, &r, portMAX_DELAY)==pdPASS){
      p.ts_ms = r.ts_ms;
      // LPF ruedas
      for(int i=0;i<4;i++) p.wheel_mps[i] = lpf(r.wheel_mps[i], p.wheel_mps[i], a_w);
      // IMU (ejemplo: copia directa + LPF en gz)
      p.ax=r.imu_ax; p.ay=r.imu_ay; p.az=r.imu_az; p.gz = lpf(r.imu_gz, p.gz, 0.2f);
      // Fusión velocidad total muy simple: promedio ruedas vs GPS (si válido)
      float v_wheels = 0.25f*(p.wheel_mps[0]+p.wheel_mps[1]+p.wheel_mps[2]+p.wheel_mps[3]);
      p.gps_speed_mps = r.gps_speed_mps;
      p.v_total_mps = (r.gps_speed_mps>0.1f)? (0.7f*r.gps_speed_mps + 0.3f*v_wheels) : v_wheels;
      // Temp y freno
      p.temp_box_c   = lpf(r.temp_box_c,   p.temp_box_c,   a_t);
      p.temp_motor_c = lpf(r.temp_motor_c, p.temp_motor_c, a_t);
      p.brake_pos    = lpf(r.brake_pos,    p.brake_pos,    0.3f);
      // Publica a cola de procesados
      xQueueOverwrite(q_proc, &p);
    }
  }
}

/* ===========================
   Tarea CAN Tx (empaqueta según Cap. 5)
   =========================== */
// Envía los datos procesados por CAN
void task_can(void *arg)
{
  TelemetryProc_t p={0};
  TickType_t t = xTaskGetTickCount();
  const TickType_t dt = pdMS_TO_TICKS(1000/RATE_PROC_HZ);
  for(;;){
    vTaskDelayUntil(&t, dt);
    if(uxQueueMessagesWaiting(q_proc)){
      xQueuePeek(q_proc, &p, 0);

      send_wheel_speed(CAN_ID_VR_FL, p.wheel_mps[0]);
      send_wheel_speed(CAN_ID_VR_FR, p.wheel_mps[1]);
      send_wheel_speed(CAN_ID_VR_RL, p.wheel_mps[2]);
      send_wheel_speed(CAN_ID_VR_RR, p.wheel_mps[3]);

      send_imu(p.ax,p.ay,p.az,p.gz);
      send_gps(p.gps_speed_mps);
      send_temp(p.temp_box_c, p.temp_motor_c);
      send_brake(p.brake_pos);
    }
  }
}

/* ===========================
   Tarea Health/Watchdog
   =========================== */
// Envía estado del sistema por CAN
void task_health(void *arg)
{
  TickType_t t = xTaskGetTickCount();
  const TickType_t dt = pdMS_TO_TICKS(1000/RATE_HEALTH_HZ);
  for(;;){
    vTaskDelayUntil(&t, dt);
    float vbat = 12.0f;      // TODO: medir si hay canal
    int8_t rssi = -50;       // TODO: si se comparte por CAN desde ESP32
    uint8_t cpu = 20;        // placeholder
    send_health(vbat, rssi, cpu);
  }
}

/* ===========================
   Callbacks e ISRs
   =========================== */
// Callback de captura de timer (ruedas)
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){
  if(htim->Instance==TIM2){
    uint32_t now = HAL_TIM_ReadCapturedValue(htim, htim->Channel);
    uint8_t ch=0;
    if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_1) ch=0;
    else if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_2) ch=1;
    else if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_3) ch=2;
    else if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_4) ch=3;
    uint32_t prev = vr_ic_ticks[ch];
    vr_ic_ticks[ch] = now;
    vr_period_ticks[ch] = (now>=prev)? (now-prev) : (htim->Instance->ARR - prev + now + 1);
    vr_new[ch]=1;
  }
}

// Callback de conversión ADC completa
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc){
  if(hadc->Instance==ADC1){ adc_new=1; }
}

// Callback de recepción UART (GPS)
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
  if(huart->Instance==USART2){
    char c = (char)gps_rx_byte;
    if(gps_rx_w<GPS_RX_BUF_SZ-1) gps_rx_buf[gps_rx_w++]=c;
    HAL_UART_Receive_IT(&huart2, (uint8_t*)&gps_rx_byte, 1);
  }
}

/* ===========================
   Inits generados por CubeMX
   (placeholders — ajusta a tu proyecto)
   =========================== */

// Configuración de reloj del sistema (debe completarse con CubeMX)
void SystemClock_Config(void)
{
  /* Configuración típica de 168 MHz (HSE 8MHz -> PLL) generada por CubeMX */
}

// Inicialización de GPIOs (debe completarse)
static void MX_GPIO_Init(void){ /* ... */ }

// Inicialización de DMA (debe completarse)
static void MX_DMA_Init(void){ /* ... habilita DMA2 Stream0 para ADC1 ... */ }

// Inicialización de I2C1
static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 400000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  HAL_I2C_Init(&hi2c1);
}

// Inicialización de UART2 (GPS)
static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 9600;     // 9600 o 115200 según GPS
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart2);
}

// Inicialización de ADC1 (3 canales)
static void MX_ADC1_Init(void)
{
  ADC_ChannelConfTypeDef sConfig = {0};
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = ADC_NUM_CH;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  HAL_ADC_Init(&hadc1);

  sConfig.SamplingTime = ADC_SAMPLETIME_56CYCLES;

  sConfig.Channel = ADC_CHANNEL_10; sConfig.Rank=1; HAL_ADC_ConfigChannel(&hadc1,&sConfig); // PC0
  sConfig.Channel = ADC_CHANNEL_11; sConfig.Rank=2; HAL_ADC_ConfigChannel(&hadc1,&sConfig); // PC1
  sConfig.Channel = ADC_CHANNEL_12; sConfig.Rank=3; HAL_ADC_ConfigChannel(&hadc1,&sConfig); // PC2
}

// Inicialización de Timer2 para Input Capture (ruedas)
static void MX_TIM2_Init(void)
{
  TIM_IC_InitTypeDef sConfigIC = {0};
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 83;     // 84MHz/84=1MHz -> 1 tick = 1us
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 0xFFFFFFFF;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_IC_Init(&htim2);

  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 2; // pequeño filtro digital
  HAL_TIM_IC_ConfigChannel(&htim2,&sConfigIC,TIM_CHANNEL_1);
  HAL_TIM_IC_ConfigChannel(&htim2,&sConfigIC,TIM_CHANNEL_2);
  HAL_TIM_IC_ConfigChannel(&htim2,&sConfigIC,TIM_CHANNEL_3);
  HAL_TIM_IC_ConfigChannel(&htim2,&sConfigIC,TIM_CHANNEL_4);
}

// Inicialización de CAN1
static void MX_CAN1_Init(void)
{
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 6;      // con APB1@42MHz -> tq ~ 1/7MHz
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
  hcan1.Init.AutoBusOff = DISABLE;
  hcan1.Init.AutoRetransmission = ENABLE;
  hcan1.Init.AutoWakeUp = ENABLE;
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TimeTriggeredMode = DISABLE;
  HAL_CAN_Init(&hcan1);
}
